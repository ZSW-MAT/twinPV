using System;
using System.Collections.Generic;
using System.Linq;
using Extreme.Mathematics;
using Extreme.Mathematics.SignalProcessing;
using Extreme.Mathematics.Curves;
using Extreme.Mathematics.LinearAlgebra;

namespace BasicLib
{
    /// <summary>
    /// contains a characteristic curve of a pn junction, solar cell or solar module with all its parameters
    /// </summary>
    public class CharacteristicCurve
    {
        /// <summary>
        /// current, which is generated by the sunlight in Ampere
        /// </summary>
        public double currentPhoto { get; set; }
        /// <summary>
        /// current, which flows back via the diode at zero voltage (reverse bias saturation current density) in Ampere
        /// </summary>
        public double currentSaturation { get; private set; }
        /// <summary>
        /// Ideality factor of the first diode
        /// </summary>
        public double diode1IdealityFactor { get; private set; }
        /// <summary>
        /// series resistor of the microcell in Ohm
        /// </summary>
        public double Rseries { get; private set; }
        /// <summary>
        /// resistor of the short cut within the microcell, where current can flow back to the back contact in Ohm
        /// </summary>
        public double Rshunt { get; private set; }

        /// <summary>
        /// temperature of this characteristic curve
        /// </summary>
        public double temperature { get; private set; }

        /// <summary>
        /// non ordered list with all measured data if this characteristics is constructed by fitting a dataset (voltage, current, power, loadresistance, efficiency)
        /// </summary>
        public List<(double voltage, double current, double power, double area, double efficiency)> experimentalData { get; private set; }
            = new List<(double voltage, double current, double power, double area, double efficiency)>();

        /// <summary>
        /// Rsquared value for the fit (NaN, if diode parameters are not set)
        /// </summary>
        public double coefficientOfDetermination { get; private set; }

        /// <summary>
        /// factor, which is multiplied to every voltage (e.g. if multiple cells are stacked in a row)
        /// </summary>
        public double factorToVoltage { get; set; } = 1;
        /// <summary>
        /// factor, which is multiplied to every current (e.g. if only part of the cell is simulated)
        /// </summary>
        public double factorToCurrent { get; set; } = 1;

        // Constructors █████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
        /// <summary>
        /// Initializes an empty characteristic curve
        /// </summary>
        public CharacteristicCurve(double temperature)
        {
            this.temperature = temperature;
            coefficientOfDetermination = double.NaN;
        }

        /// <summary>
        /// Initializes the characteristic curve from a set of parameters (set Rseries or Rshunt to NaN if you dont want to have them in the model)
        /// </summary>
        /// <param name="currentPhoto">current, which is generated by the sunlight in Ampere</param>
        /// <param name="currentSaturation">current, which flows back via the diode at zero voltage (reverse bias saturation current density) in Ampere</param>
        /// <param name="diode1IdealityFactor">Ideality factor of the first diode</param>
        /// <param name="Rseries">series resistor of the microcell in Ohm</param>
        /// <param name="Rshunt">resistor of the short cut within the microcell, where current can flow back to the back contact in Ohm</param>
        public CharacteristicCurve(double temperature, double currentPhoto, double currentSaturation, double diode1IdealityFactor,
            double Rseries = double.NaN, double Rshunt = double.NaN)
        {
            this.temperature = temperature;
            this.currentPhoto = currentPhoto;
            this.currentSaturation = currentSaturation;
            this.diode1IdealityFactor = diode1IdealityFactor;
            this.Rseries = Rseries == 0 ? double.NaN : Rseries;
            this.Rshunt = Rshunt;
            coefficientOfDetermination = 1;
        }

        /// <summary>
        /// Initializes the characteristic curve from experimental values and a initial parameter guesses (set parameters to NaN if you don't know a good initial guess)
        /// </summary>
        /// <param name="experimentalData">array with all measured voltages and currents (below Voc the currents need to be negative!)</param>
        /// <param name="currentPhoto">current, which is generated by the sunlight in Ampere</param>
        /// <param name="currentSaturation">current, which flows back via the diode at zero voltage (reverse bias saturation current density) in Ampere</param>
        /// <param name="diode1IdealityFactor">Ideality factor of the first diode</param>
        /// <param name="Rseries">series resistor of the microcell in Ohm</param>
        /// <param name="Rshunt">resistor of the short cut within the microcell, where current can flow back to the back contact in Ohm</param>
        public CharacteristicCurve(double temperature, List<(double voltage, double current, double power, double area, double efficiency)> experimentalData,
            bool executeFit = true, double currentPhoto = double.NaN, double currentSaturation = double.NaN, double diode1IdealityFactor = double.NaN,
            double Rseries = double.NaN, double Rshunt = double.NaN)
        {
            this.temperature = temperature;
            this.experimentalData = experimentalData;
            if (executeFit)
                ExecuteFit(currentPhoto, currentSaturation, diode1IdealityFactor, Rseries, Rshunt);
            else
                coefficientOfDetermination = double.NaN;
        }

        // Adds a new expemental data point █████████████████████████████████████████████████████████████████████████████████████████████████████████
        /// <summary>
        /// Adds a new expemental data point and fits all points
        /// </summary>
        public void AddExperimentalPoint((double voltage, double current, double power, double area, double efficiency) experimentalDataPoint)
        {
            experimentalData.Add(experimentalDataPoint);
        }

        // Perform Fit ██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
        /// <summary>
        /// Performs a fit for the given experimental data set (set parameters to NaN if you don't know a good initial guess)
        /// </summary>
        /// <param name="currentPhoto">current, which is generated by the sunlight in Ampere</param>
        /// <param name="currentSaturation">current, which flows back via the diode at zero voltage (reverse bias saturation current density) in Ampere</param>
        /// <param name="diode1IdealityFactor">Ideality factor of the first diode</param>
        /// <param name="Rseries">series resistor of the microcell in Ohm</param>
        /// <param name="Rshunt">resistor of the short cut within the microcell, where current can flow back to the back contact in Ohm</param>
        public void ExecuteFit(double currentPhoto = double.NaN, double currentSaturation = double.NaN, double diode1IdealityFactor = double.NaN,
            double Rseries = double.NaN, double Rshunt = double.NaN)
        {
            // Fitting procedure:
            //    1. Savitsky Golay filter and mirror values if Isc is positive
            //    2. MPP point from maximum power
            //    3. Voc from interpolation of two datapoints or if only negative currents: Voc = 1.2 * V_MPP
            //    4. Fit of all values below 20% of Voc (at least 5 data points) => inverse slope is Rsh, offset is Iph
            //    5. Fit 5 larges data points. Rs is inverse slope
            //    6. n = 2 * Voc
            //    7. I0: claculate from Voc data set via diode equation

            // Initial guess ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

            var orderedExperimentalData = experimentalData.OrderBy(d => d.voltage).ToList();

            // Mirror values if Isc is positive and apply Savitsky Golay filter
            var voltages = orderedExperimentalData.Select(e => e.voltage).ToArray();
            var currents = Smoothing.SavitskyGolay(-Math.Sign(orderedExperimentalData.First().current) * Vector.Create(orderedExperimentalData.Select(e => e.current).ToArray()), 9, 3).ToArray();

            // maximum power point
            int indexMPP = -1;
            double P_MPP = -1;
            double V_MPP = -1;
            double I_MPP = -1;
            for (int i = 0; i < voltages.Length; i++)
            {
                double power = - voltages[i] * currents[i];
                if (power > P_MPP)
                {
                    indexMPP = i;
                    P_MPP = power;
                    V_MPP = voltages[i];
                    I_MPP = -currents[i];
                }
            }

            // open circuit voltage
            (int indexBehind, double value) Voc = (0, 1);
            if (currents.Any(c => c < 0) && currents.Any(c => c > 0))
            {
                for (int i = 0; i < voltages.Length; i++)
                    if (currents[i] > 0)
                    {
                        double m = (currents[i] - currents[i - 1]) / (voltages[i] - voltages[i - 1]);
                        double b = currents[i] - m * voltages[i];
                        Voc = (i, -b / m);
                        break;
                    }
            }
            else
            {
                Voc = (-100, V_MPP * 1.2);
            }

            // Rsh and Iph
            List<(double voltage, double current)> dataShuntFit = new List<(double voltage, double current)>();
            for (int i = 0; voltages[i] < 0.2 * Voc.value || dataShuntFit.Count < 5; i++)
                dataShuntFit.Add((voltages[i], currents[i]));
            LinearCurveFitter fitterShunt = new LinearCurveFitter();
            fitterShunt.Curve = new Polynomial(1);
            fitterShunt.XValues = dataShuntFit.Select(d => d.voltage).ToArray();
            fitterShunt.YValues = dataShuntFit.Select(d => d.current).ToArray();
            double slopeShunt = (fitterShunt.YValues.Max() - fitterShunt.YValues.Min()) / (fitterShunt.XValues.Max() - fitterShunt.XValues.Min());
            fitterShunt.InitialGuess = Vector.Create(fitterShunt.YValues.Min() - fitterShunt.XValues.Min() * slopeShunt, slopeShunt);
            fitterShunt.Fit();
            double Rsh = double.IsNaN(Rshunt) ? 1 / fitterShunt.BestFitParameters[1] : Rshunt;
            double Iph = double.IsNaN(currentPhoto) ? -fitterShunt.BestFitParameters[0] : currentPhoto;

            // Rs
            LinearCurveFitter fitterSeries = new LinearCurveFitter();
            fitterSeries.Curve = new Polynomial(1);
            fitterSeries.XValues = voltages.Reverse().Take(5).Reverse().ToArray();
            fitterSeries.YValues = currents.Reverse().Take(5).Reverse().ToArray();
            double slopeSeries = (fitterSeries.YValues.Max() - fitterSeries.YValues.Min()) / (fitterSeries.XValues.Max() - fitterSeries.XValues.Min());
            fitterSeries.InitialGuess = Vector.Create(fitterSeries.YValues.Min() - fitterSeries.XValues.Min() * slopeSeries, slopeSeries);
            fitterSeries.Fit();
            double Rs = double.IsNaN(Rseries) ? (currents.Where(c => c > 0).Count() > 2 ? 1 : 0.5) / fitterSeries.BestFitParameters[1] : Rseries;

            // n
            double n = double.IsNaN(diode1IdealityFactor) ? 2 * Voc.value : diode1IdealityFactor;

            // I0
            double I0 = double.IsNaN(currentSaturation) ? (Iph - Voc.value / Rsh) / (Math.Exp((physConstants.e * Voc.value) / (n * physConstants.kB * temperature)) - 1) : currentSaturation;

            double[] initialGuess = new double[] { Iph, I0, n, Rs, Rsh };

            // Fit via one diode model ——————————————————————————————————————————————————————————————————————————————————————————————————————————————

            // fit without Rsh and Iph
            NonlinearCurveFitter fitter_noRsh = new NonlinearCurveFitter();
            fitter_noRsh.Curve = new IVcurve(temperature, initialGuess, new bool[] { false, true, true, true, false });
            fitter_noRsh.XValues = orderedExperimentalData.Select(d => d.voltage).ToArray();
            fitter_noRsh.YValues = orderedExperimentalData.Select(d => d.current).ToArray();
            fitter_noRsh.Fit();

            // fit with all parameters
            NonlinearCurveFitter fitter = new NonlinearCurveFitter();
            fitter.Curve = new IVcurve(temperature, new double[] { initialGuess[0], fitter_noRsh.BestFitParameters[0], fitter_noRsh.BestFitParameters[1], fitter_noRsh.BestFitParameters[2], initialGuess[4] },
                new bool[] { true, true, true, true, true });
            fitter.XValues = orderedExperimentalData.Select(d => d.voltage).ToArray();
            fitter.YValues = orderedExperimentalData.Select(d => d.current).ToArray();
            fitter.Fit();

            // Write fitted parameters 
            this.currentPhoto = fitter.BestFitParameters[0] < 0 ? initialGuess[0] * 1e-3 : fitter.BestFitParameters[0];
            this.currentSaturation = fitter.BestFitParameters[1] < 0 ? initialGuess[1] * 1e-3 : fitter.BestFitParameters[1];
            this.diode1IdealityFactor = fitter.BestFitParameters[2] < 0 ? initialGuess[2] * 1e-3 : fitter.BestFitParameters[2];
            this.Rseries = fitter.BestFitParameters[3] < 0 ? initialGuess[3] * 1e-3 : fitter.BestFitParameters[3];
            this.Rshunt = fitter.BestFitParameters[4] < 0 ? initialGuess[4] * 1e-3 : fitter.BestFitParameters[4];

            // Get the Rsquared values of the fit following https://en.wikipedia.org/wiki/Coefficient_of_determination
            double SSres = 0;
            for (int i = 0; i < orderedExperimentalData.Select(d => d.voltage).ToArray().Length; i++)
                SSres += ChiSquared(orderedExperimentalData.Select(d => d.voltage).ToArray()[i],
                    orderedExperimentalData.Select(d => d.current).ToArray()[i], new double[] { this.currentPhoto, this.currentSaturation, this.diode1IdealityFactor, this.Rseries, this.Rshunt });
            coefficientOfDetermination = 1 - SSres / orderedExperimentalData.Select(d => d.current).ToArray().Sum(y =>
                Math.Pow(y - orderedExperimentalData.Select(d => d.current).ToArray().Average(), 2));

            double ChiSquared(double voltage, double current, double[] parameters)
            {
                return Math.Pow(current - GetCurrentAtVoltage(voltage, parameters[0], parameters[1], parameters[2], parameters[3], parameters[4]), 2);
            }
            

            
            // OLD FITTING PROCEDURE

            /*
            // Fitting procedure:
            //    1. Get Voc as the voltage value, with the smallest absolute value of current
            //    2. Fit all values above Voc -> slope of fit is Rs
            //    3. Fit all values below Voc/2 (according to voltage, not indexes) -> slope of fit is Rsh, y-intercept is Iph
            //    4. Fit all values exponential -> exponent indicates n
            //    5. Solve diode equation at Voc for I0 (for simplicity without Rs) -> calculate I0
            //    6. Fit all values with fixed Rsh
            //    7. Fit all values with all parameters

            var orderedExperimentalData = experimentalData.OrderBy(d => d.voltage).ToList();

            // Initial guess ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
            if (double.IsNaN(currentPhoto) || double.IsNaN(currentSaturation) ||
                double.IsNaN(diode1IdealityFactor) || double.IsNaN(Rseries) || double.IsNaN(Rshunt))
            {
                // Determine Voc from current closest to zero
                double smallestCurrent = orderedExperimentalData.Select(d => d.current).Aggregate((momentan, next) =>
                Math.Abs(momentan) < Math.Abs(next) ? momentan : next);
                int indexVoc = orderedExperimentalData.Select(d => d.current).ToList().IndexOf(smallestCurrent);
                double Voc = orderedExperimentalData.Select(d => d.voltage).ToList()[indexVoc];

                Console.WriteLine("Voc = " + Voc);

                // Get Rs
                if (double.IsNaN(Rseries))
                {
                    LinearCurveFitter fitterAbove = new LinearCurveFitter();
                    fitterAbove.Curve = new Polynomial(1);
                    fitterAbove.XValues = orderedExperimentalData.Select(d => d.voltage).Skip(indexVoc).ToArray();
                    fitterAbove.YValues = orderedExperimentalData.Select(d => d.current).Skip(indexVoc).ToArray();
                    if (fitterAbove.XValues.ToList().Count > 1)
                    {
                        double slope = (fitterAbove.YValues.Max() - fitterAbove.YValues.Min()) / (fitterAbove.XValues.Max() - fitterAbove.XValues.Min());
                        fitterAbove.InitialGuess = Vector.Create(fitterAbove.YValues.Min() - fitterAbove.XValues.Min() * slope, slope);
                        fitterAbove.Fit();
                        this.Rseries = 0.7 / fitterAbove.BestFitParameters[1];
                    }
                    else
                    {
                        this.Rseries = 1e-8;
                    }
                }
                else
                    this.Rseries = Rseries;

                Console.WriteLine("rs  = " + this.Rseries);

                // Get Iph and Rp
                if (double.IsNaN(currentPhoto) || double.IsNaN(Rshunt))
                {
                    var VmaxLinear = orderedExperimentalData.Select(d => d.voltage).ToArray().Aggregate((momentan, next) => Math.Abs(momentan - 0.5 * Voc)
                        < Math.Abs(next - 0.5 * Voc) ? momentan : next);
                    int indexVmaxLinear = orderedExperimentalData.Select(d => d.voltage).ToArray().ToList().IndexOf(VmaxLinear);
                    LinearCurveFitter fitterBelow = new LinearCurveFitter();
                    fitterBelow.Curve = new Polynomial(1);
                    fitterBelow.XValues = orderedExperimentalData.Select(d => d.voltage).ToArray().Take(indexVmaxLinear).ToArray();
                    fitterBelow.YValues = orderedExperimentalData.Select(d => d.current).ToArray().Take(indexVmaxLinear).ToArray();

                    if (fitterBelow.XValues.ToList().Count > 1)
                    {
                        fitterBelow.Fit();

                        if (double.IsNaN(currentPhoto))
                            this.currentPhoto = -fitterBelow.BestFitParameters[0];
                        else
                            this.currentPhoto = currentPhoto;

                        if (double.IsNaN(Rshunt))
                            this.Rshunt = 1 / fitterBelow.BestFitParameters[1] - this.Rseries;
                        else
                            this.Rshunt = Rshunt;
                    }
                    else
                    {
                        if (double.IsNaN(currentPhoto))
                            this.currentPhoto = -orderedExperimentalData.Select(d => d.current).First();
                        else
                            this.currentPhoto = currentPhoto;

                        if (double.IsNaN(Rshunt))
                            this.Rshunt = 1;
                        else
                            this.Rshunt = Rshunt;
                    }
                }
                else
                {
                    this.currentPhoto = currentPhoto;
                    this.Rshunt = Rshunt;
                }

                Console.WriteLine("iph = " + this.currentPhoto);
                Console.WriteLine("rsh = " + this.Rshunt);

                // Get n
                if (double.IsNaN(currentPhoto))
                {
                    NonlinearCurveFitter fitterAround = new NonlinearCurveFitter();
                    fitterAround.Curve = new ExpCurve(1e-7 * this.currentPhoto, 25, -this.currentPhoto);
                    fitterAround.XValues = orderedExperimentalData.Select(d => d.voltage).ToArray();
                    fitterAround.YValues = orderedExperimentalData.Select(d => d.current).ToArray();
                    fitterAround.Fit();

                    this.diode1IdealityFactor = 25 / fitterAround.BestFitParameters[1];
                    //this.diode1IdealityFactor = this.diode1IdealityFactor < 1 ? 1 : this.diode1IdealityFactor;
                    //this.diode1IdealityFactor = this.diode1IdealityFactor > 5 ? 5 : this.diode1IdealityFactor;
                }
                else
                    this.diode1IdealityFactor = diode1IdealityFactor;
                //this.diode1IdealityFactor = 1.8 * Voc;
                Console.WriteLine("n = " + this.diode1IdealityFactor);
                Console.WriteLine("kB = " + physConstants.kB);
                Console.WriteLine("e = " + physConstants.e);
                Console.WriteLine("T = " + temperature);

                // Get I0
                if (double.IsNaN(currentSaturation))
                    this.currentSaturation = this.currentPhoto / (Math.Exp((physConstants.e * Voc)
                        / (this.diode1IdealityFactor * physConstants.kB * temperature)) - 1);
                else
                    this.currentSaturation = currentSaturation;

                Console.WriteLine("j0  = " + this.currentSaturation);
            }
            else
            {
                this.currentPhoto = currentPhoto;
                this.currentSaturation = currentSaturation;
                this.diode1IdealityFactor = diode1IdealityFactor;
                this.Rseries = Rseries;
                this.Rshunt = Rshunt;
            }

            Console.WriteLine();

            if (double.IsNaN(this.currentPhoto) || double.IsNaN(this.currentSaturation) || double.IsNaN(this.diode1IdealityFactor) || double.IsNaN(this.Rseries) || double.IsNaN(this.Rshunt))
            {
                Console.WriteLine("Init guess for fitting was NaN:");
                Console.WriteLine("jph = " + this.currentPhoto);
                Console.WriteLine("j0  = " + this.currentSaturation);
                Console.WriteLine("n   = " + this.diode1IdealityFactor);
                Console.WriteLine("Rs  = " + this.Rseries);
                Console.WriteLine("Rsh = " + this.Rshunt + "\n");
                return;
            }

            Console.WriteLine("\ninit guess");
            Console.WriteLine("jph = " + this.currentPhoto);
            Console.WriteLine("j0  = " + this.currentSaturation);
            Console.WriteLine("n   = " + this.diode1IdealityFactor);
            Console.WriteLine("Rs  = " + this.Rseries);
            Console.WriteLine("Rsh = " + this.Rshunt + "\n");
            

            // Fit via one diode model ——————————————————————————————————————————————————————————————————————————————————————————————————————————————

            double[] initialGuess = new double[] { this.currentPhoto, this.currentSaturation, this.diode1IdealityFactor, this.Rseries, this.Rshunt };

            // fit without Rsh
            NonlinearCurveFitter fitter_noRsh = new NonlinearCurveFitter();
            fitter_noRsh.Curve = new IVcurve(this.temperature, initialGuess, new bool[] { true, true, true, true, false });
            fitter_noRsh.XValues = orderedExperimentalData.Select(d => d.voltage).ToArray();
            fitter_noRsh.YValues = orderedExperimentalData.Select(d => d.current).ToArray();
            fitter_noRsh.Fit();

            // fit with all parameters
            NonlinearCurveFitter fitter = new NonlinearCurveFitter();
            fitter.Curve = new IVcurve(this.temperature, new double[] { fitter_noRsh.BestFitParameters[0], fitter_noRsh.BestFitParameters[1], fitter_noRsh.BestFitParameters[2], fitter_noRsh.BestFitParameters[3], initialGuess[4] },
                new bool[] { true, true, true, true, true });
            fitter.XValues = orderedExperimentalData.Select(d => d.voltage).ToArray();
            fitter.YValues = orderedExperimentalData.Select(d => d.current).ToArray();
            fitter.Fit();

            // Write fitted parameters 
            this.currentPhoto = fitter.BestFitParameters[0];
            this.currentSaturation = fitter.BestFitParameters[1];
            this.diode1IdealityFactor = fitter.BestFitParameters[2];
            this.Rseries = fitter.BestFitParameters[3];
            this.Rshunt = fitter.BestFitParameters[4];

            // Get the Rsquared values of the fit following https://en.wikipedia.org/wiki/Coefficient_of_determination
            double SSres = 0;
            for (int i = 0; i < orderedExperimentalData.Select(d => d.voltage).ToArray().Length; i++)
                SSres += ChiSquared(orderedExperimentalData.Select(d => d.voltage).ToArray()[i],
                    orderedExperimentalData.Select(d => d.current).ToArray()[i], fitter.BestFitParameters.ToArray());
            coefficientOfDetermination = 1 - SSres / orderedExperimentalData.Select(d => d.current).ToArray().Sum(y =>
                Math.Pow(y - orderedExperimentalData.Select(d => d.current).ToArray().Average(), 2));

            double ChiSquared(double voltage, double current, double[] parameters)
            {
                return Math.Pow(current - GetCurrentAtVoltage(voltage, parameters[0], parameters[1], parameters[2], parameters[3], parameters[4]), 2);
            }*/
        }

        // Returns the current for a certain voltage ████████████████████████████████████████████████████████████████████████████████████████████████
        /// <summary>
        /// Returns the current in Ampere from a certain voltage
        /// </summary>
        /// <param name="voltage">voltage [V], at which the current is calculated</param>
        /// <param name="specialIph">current photo</param>
        /// <param name="specialI0">current saturation</param>
        /// <param name="special_n">diode ideality facotr</param>
        /// <param name="specialRs">series resistance</param>
        /// <param name="specialRp">prallel / shunt resistance</param>
        /// <returns></returns>
        public double GetCurrentAtVoltage(double voltage, double? specialIph = null, double? specialI0 = null, double? special_n = null,
            double? specialRs = null, double? specialRp = null)
        {
            voltage /= factorToVoltage;

            double Iph = specialIph ?? currentPhoto;
            double I0 = specialI0 ?? currentSaturation;
            double n = special_n ?? diode1IdealityFactor;
            double Rs = specialRs ?? Rseries;
            double Rsh = specialRp ?? Rshunt;

            // Solve implicit function of the diode model to determine the generated current
            // Calculate the current according to the diode model (depends on whether Rs and Rp are present or not)
            //
            //                                /      / e * ( Φ_k - Rs * I )  \     \       Φ_k - Rs * I
            //           I  =  - Iph  +  I0 〈  exp〈 ———————————————————————— ⟩ - 1 ⟩  +  ———————————————
            //                                \      \      n * kB * T       /     /           Rp
            //
            // with
            // I   : total current (flows over Rs)
            // Iph : photocurrent, which is generated by the generation rate (Iph = jph * A)
            // I0  : reverse leakage current of the diode
            // Φ_k : potential on top of the cell (above Rs)
            // Rs  : series resistance in diode model
            // Rp  : parallel shunt resistance in diode model
            // n   : ideality factor of the diode

            // R_P = ∞ & R_S = 0 ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
            //
            //                                /      /  e * Φ_k   \     \
            //           I  =  - Iph  +  I0 〈  exp〈 ————————————— ⟩ - 1 ⟩
            //                                \      \ n * kB * T /     /
            //
            if (double.IsNaN(Rs) && double.IsNaN(Rsh))
            {
                return (-Iph + I0 * (Math.Exp(physConstants.e * voltage / (n * physConstants.kB * temperature)) - 1)) * factorToCurrent;
            }

            // R_P normal & R_S = 0 —————————————————————————————————————————————————————————————————————————————————————————————————————————————————
            //
            //                                /      /  e * Φ_k   \     \       Φ_k
            //           I  =  - Iph  +  I0 〈  exp〈 ————————————— ⟩ - 1 ⟩  +  ——————
            //                                \      \ n * kB * T /     /       Rp
            //
            else if (double.IsNaN(Rs) && !double.IsNaN(Rsh))
            {
                return (-Iph + I0 * (Math.Exp(physConstants.e * voltage / (n * physConstants.kB * temperature)) - 1) + voltage / Rsh) * factorToCurrent;
            }

            // R_P = ∞ & R_S normal —————————————————————————————————————————————————————————————————————————————————————————————————————————————————
            // 
            //                  n * kB * T      / q * I0 * Rs         / q * ( (Iph + I0) * Rs + Φ_k ) \ \
            //           I  =  ———————————— 𝒲〈 ——————————————  exp〈 ———————————————————————————————— ⟩ ⟩  -  Iph  -  I0
            //                    e * Rs        \ n * kB * T          \          n * kB * T           / /
            //
            else if (!double.IsNaN(Rs) && double.IsNaN(Rsh))
            {
                double inputL = I0 * physConstants.e * Rs / (n * physConstants.kB * temperature)
                    * Math.Exp(physConstants.e * ((Iph + I0) * Rs + voltage) / (n * physConstants.kB * temperature));
                return (n * physConstants.kB * temperature / (physConstants.e * Rs) * Misc.LambertW(inputL) - Iph - I0) * factorToCurrent;
            }

            // R_P normal & R_S normal ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
            //
            //                 n * kB * T                   1       /                     \
            //           I  =  ——————————— 𝒲(f(Φ_k)) + ————————— 〈 Φ_k - Rp * (Iph + I0) ⟩
            //                   q * Rs                  Rs + Rp    \                     /
            //
            //           with
            //                          q * I0 * Rs * Rp          / q * Rp * ( Rs * (Iph + I0) + Φ_k )  \
            //           f(Φ_k)  =  ———————————————————————— exp〈 ————————————————————————————————————— ⟩
            //                       (Rs + Rp) * n * kB * T       \       (Rs + Rp) * n * kB * T        /
            //
            else
            {
                double inputL = physConstants.e * I0 * Rs * Rsh / ((Rs + Rsh) * n * physConstants.kB * temperature)
                    * Math.Exp(physConstants.e * Rsh * (Rs * (Iph + I0) + voltage) / ((Rs + Rsh) * n * physConstants.kB * temperature));
                return (n * physConstants.kB * temperature / (physConstants.e * Rs) * Misc.LambertW(inputL)
                    + 1 / (Rsh + Rs) * (voltage - Rsh * (Iph + I0))) * factorToCurrent;
            }
        }

        // derivations ██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
        /// <summary>
        /// Returns derivation accoriding to the voltage of the current
        /// </summary>
        /// <param name="voltage">voltage [V], at which the derivation is calculated</param>
        /// <returns></returns>
        public double GetCurrentAtVoltageDerivation_V(double voltage, double? specialIph = null, double? specialI0 = null, double? special_n = null,
            double? specialRs = null, double? specialRp = null)
        {
            voltage /= factorToVoltage;

            double Iph = specialIph ?? currentPhoto;
            double I0 = specialI0 ?? currentSaturation;
            double n = special_n ?? diode1IdealityFactor;
            double Rs = specialRs ?? Rseries;
            double Rsh = specialRp ?? Rshunt;

            // R_P = ∞ & R_S = 0 ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
            //
            //                            e                    /  e * Φ_k   \
            //           ∂I/∂Φ_k  =  ————————————  * I0 * exp〈 ————————————— ⟩
            //                        n * kB * T               \ n * kB * T /
            //
            if (double.IsNaN(Rs) && double.IsNaN(Rsh))
            {
                return (physConstants.e / (n * physConstants.kB * temperature)
                    * I0 * Math.Exp(physConstants.e * voltage / (n * physConstants.kB * temperature))) * factorToCurrent;
            }

            // R_P normal & R_S = 0 —————————————————————————————————————————————————————————————————————————————————————————————————————————————————
            //
            //                            e                    /  e * Φ_k   \        1
            //           ∂I/∂Φ_k  =  ————————————  * I0 * exp〈 ————————————— ⟩  +  —————
            //                        n * kB * T               \ n * kB * T /        Rp
            //
            else if (double.IsNaN(Rs) && !double.IsNaN(Rsh))
            {
                return (physConstants.e / (n * physConstants.kB * temperature)
                    * I0 * Math.Exp(physConstants.e * voltage / (n * physConstants.kB * temperature))
                    + 1 / Rsh) * factorToCurrent;
            }

            // R_P = ∞ & R_S normal —————————————————————————————————————————————————————————————————————————————————————————————————————————————————
            // 
            //                              𝒲(f(Φ_k))
            //           ∂I/∂Φ_k  =  e * ————————————————
            //                            𝒲(f(Φ_k)) + 1    
            //
            //           with
            //                       q * I0 * Rs         / q * ( (Iph + I0) * Rs + Φ_k ) \
            //           f(Φ_k)  =  ——————————————  exp〈 ———————————————————————————————— ⟩
            //                       n * kB * T          \          n * kB * T           /
            //
            else if (!double.IsNaN(Rs) && double.IsNaN(Rsh))
            {
                double inputLambertFunction = physConstants.e * I0 * Rs / (n * physConstants.kB * temperature)
                    * Math.Exp(physConstants.e * ((Iph + I0) * Rs + voltage)
                    / (n * physConstants.kB * temperature));
                return (physConstants.e * Misc.LambertW(inputLambertFunction)
                    / (Misc.LambertW(inputLambertFunction) + 1)) * factorToCurrent;
            }

            // R_P normal & R_S normal ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
            //
            //                        ( 1/Rs  -  1/(Rs + Rp) )  *  𝒲(f(Φ_k))          1
            //           ∂I/∂Φ_k  =  —————————————————————————————————————————  +  —————————
            //                                   𝒲(f(Φ_k))  +  1                   Rs + Rp
            //
            //           with
            //                          q * I0 * Rs * Rp          / q * Rs * ( Rp * (Iph + I0) - Φ_k )         q * Φ_k   \
            //           f(Φ_k)  =  ———————————————————————— exp〈 —————————————————————————————————————  +  ———————————— ⟩
            //                       (Rs + Rp) * n * kB * T       \       (Rs + Rp) * n * kB * T              n * kB * T /
            //
            else
            {
                double inputLambert = physConstants.e * I0 * Rs * Rsh
                    / ((Rs + Rsh) * n * physConstants.kB * temperature)
                    * Math.Exp(physConstants.e * Rs * (Rsh * (Iph + I0) - voltage)
                    / ((Rs + Rsh) * n * physConstants.kB * temperature)
                    + physConstants.e * voltage / (n * physConstants.kB * temperature));
                return ((1 / Rs - 1 / (Rs + Rsh)) * Misc.LambertW(inputLambert) / (Misc.LambertW(inputLambert) + 1)
                    + 1 / (Rs + Rsh)) * factorToCurrent;
            }
        }

        /// <summary>
        /// Returns derivation accoriding to Iph of the current
        /// </summary>
        /// <param name="voltage">voltage [V], at which the derivation is calculated</param>
        /// <returns></returns>
        public double GetCurrentAtVoltageDerivation_Iph(double voltage, double? specialIph = null, double? specialI0 = null, double? special_n = null,
            double? specialRs = null, double? specialRp = null)
        {
            voltage /= factorToVoltage;

            double Iph = specialIph ?? currentPhoto;
            double I0 = specialI0 ?? currentSaturation;
            double n = special_n ?? diode1IdealityFactor;
            double Rs = specialRs ?? Rseries;
            double Rsh = specialRp ?? Rshunt;

            // R_S = 0 ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
            if (double.IsNaN(Rs))
            {
                return -1;
            }

            // R_P = ∞ & R_S normal —————————————————————————————————————————————————————————————————————————————————————————————————————————————————
            else if (double.IsNaN(Rsh))
            {
                // short forms
                double T = temperature;
                double e = physConstants.e;
                double kB = physConstants.kB;
                double U = voltage;
                double exp = Math.Exp(e * ((Iph + I0) * Rs - U) / (n * kB * T));
                double f = e * I0 * Rs / (n * kB * T) * exp;
                double W = Misc.LambertW(f);

                double dfdIph = e * Rs / (n * kB * T) * f;
                return n * kB * T / (e * Rs) * dfdIph * W / (f * W + f) - 1;
            }

            // R_P normal & R_S normal ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
            else
            {
                // short forms
                double T = temperature;
                double e = physConstants.e;
                double kB = physConstants.kB;
                double U = voltage;
                double exp = Math.Exp(e * Rs * (Rsh * (Iph + I0) - U) / ((Rs + Rsh) * n * kB * T) + e * U / (n * kB * T));
                double f = e * I0 * Rs * Rsh / ((Rs + Rsh) * n * kB * T) * exp;
                double W = Misc.LambertW(f);

                double dfdIph = e * Rs * Rsh / ((Rs + Rsh) * n * kB * T) * f;
                return n * kB * T / (e * Rs) * dfdIph * W / (f * W + f) - Rsh / (Rs + Rsh);
            }
        }

        // Returns the produced power for a certain voltage █████████████████████████████████████████████████████████████████████████████████████████
        /// <summary>
        /// Returns the produced power in Watt from a certain voltage (positive = produces power, negative = consumes power)
        /// </summary>
        /// <param name="voltage">voltage [V], at which the current is calculated</param>
        /// <returns></returns>
        public double GetPowerAtVoltage(double voltage)
        {
            // Return Power, as P = V * I
            return voltage * GetCurrentAtVoltage(voltage);
        }

        // Calculates datasets ██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
        /// <summary>
        /// Calculates the dataset for the open circuit configuration (Current = 0) [Volt, Ampere, Watt, %]
        /// </summary>
        /// <returns></returns>
        public (double voltage, double current, double power, double fillfactor) GetDataSetOpenCircuit()
        {
            return (GetVoltageOpenCircuit(), 0, 0, 0);
        }
        /// <summary>
        /// Calculates the voltage in volt for the open circuit configuration (Current = 0)
        /// </summary>
        /// <returns></returns>
        private double GetVoltageOpenCircuit()
        {
            // Calculate the open circuit voltage (either via lambertW or via the logarithm if Rshunt is not present) (Rseries doesn't matter)
            if (double.IsNaN(Rshunt))
            {
                // return Voc
                return (diode1IdealityFactor * physConstants.kB * temperature / physConstants.e * Math.Log(currentPhoto / currentSaturation + 1)) * factorToVoltage;
            }
            else
            {
                // Determine exponent in the Lambert function (might be to big for the exponent of a double)
                double exp = physConstants.e * Rshunt * (currentPhoto + currentSaturation) / (diode1IdealityFactor * physConstants.kB * temperature);

                // Calculate the lambertW function (either with exact value or with log-approximation)
                double lambert;
                if (exp > 300)
                {
                    // approximation for large x in W(x) = log(x)  -  log(log(x))  +  log(log(x))/log(x)
                    // one can directly use log(a*e^b) = log(a) + b to not have the b in the exponent of the double number
                    double w1LOGw2 = Math.Log(currentSaturation * physConstants.e * Rshunt / (diode1IdealityFactor * physConstants.kB * temperature)) + exp;
                    lambert = w1LOGw2 - Math.Log(w1LOGw2) + Math.Log(w1LOGw2) / w1LOGw2;
                }
                else
                {
                    // exact formula of W(x)
                    lambert = Misc.LambertW(currentSaturation * physConstants.e * Rshunt / (diode1IdealityFactor * physConstants.kB * temperature)
                        * Math.Exp(exp));
                }

                // return Voc
                return (Rshunt * (currentPhoto + currentSaturation) - diode1IdealityFactor * physConstants.kB * temperature / physConstants.e * lambert) * factorToVoltage;
            }
        }

        /// <summary>
        /// Calculates the dataset for the short circuit configuration (Voltage = 0) [Volt, Ampere, Watt, %]
        /// </summary>
        /// <returns></returns>
        public (double voltage, double current, double power, double fillfactor) GetDataSetShortCircuit()
        {
            return (0, GetCurrentAtVoltage(0), 0, 0);
        }

        /// <summary>
        /// Calculates the dataset for the maximum power point configuration [Volt, Ampere, Watt, %]
        /// </summary>
        /// <returns></returns>
        public (double voltage, double current, double power, double fillfactor) GetDataSetMaximumPowerPoint()
        {
            double Vmpp = GetVoltageMaximumPowerPoint();
            double Impp = GetCurrentAtVoltage(Vmpp);
            return (Vmpp, Impp, Vmpp * Impp, 100 * Vmpp * Impp / (GetVoltageOpenCircuit() * GetCurrentAtVoltage(0)));
        }
        /// <summary>
        /// Calculates the voltage in volt for the maximum power point configuration
        /// </summary>
        /// <returns></returns>
        private double GetVoltageMaximumPowerPoint()
        {
            // Specify constants (othervise lambda expression in delegate cannot access these values)
            double Iph = currentPhoto;
            double I0 = currentSaturation;
            double n = diode1IdealityFactor;
            double Rs = Rseries;
            double Rp = Rshunt;

            // Calculate the voltage at the maximum power point according to the diode model (depends on whether Rs and Rp are present or not)
            if (double.IsNaN(Rseries) && double.IsNaN(Rshunt)) // Diode model without Rs and without Rp           ->  I = I()
            {
                return ((n * physConstants.kB * temperature) / physConstants.e
                    * (Misc.LambertW((Iph / currentSaturation + 1) * Math.E) - 1)) * factorToVoltage;
            }

            else if (double.IsNaN(Rseries) && !double.IsNaN(Rshunt)) // Diode model without Rs and with Rp        ->  I = I(Rp)
            {
                // Specity delegate function, which will be searched for its root (maximum in power is root in derivation)
                Func<double, double> dPdV = V => -Iph + I0 * Math.Exp(physConstants.e * V / (n * physConstants.kB * temperature))
                * (1 + physConstants.e * V / (n * physConstants.kB * temperature)) - I0 + V / Rp;

                // Specity delegate derivate functions for newton method (no numerical derivation needed)
                Func<double, double> dP2dV2 = V => I0 * physConstants.e / (n * physConstants.kB * temperature)
                * Math.Exp(physConstants.e * V / (n * physConstants.kB * temperature))
                * (2 + physConstants.e * V / (n * physConstants.kB * temperature)) + 1 / Rp;

                // return Vmpp
                return (QuickSolving.FindRootViaNewtonMethod(dPdV, dP2dV2, 0.9 * GetVoltageOpenCircuit() / factorToVoltage, 1e-10)) * factorToVoltage;
            }

            else if (!double.IsNaN(Rseries) && double.IsNaN(Rshunt)) // Diode model with Rs and without Rp        ->  I = I(Rs)
            {
                // Specity certain delegate functions, where the last one will be searched for its root (maximum in power is root in derivation)
                Func<double, double> inputL = V => I0 * Rs * physConstants.e / (n * physConstants.kB * temperature)
                    * Math.Exp(physConstants.e * ((Iph + I0) * Rs + V) / (n * physConstants.kB * temperature));
                Func<double, double> dinputLdV = V => I0 * Rs * Math.Pow(physConstants.e / (n * physConstants.kB * temperature), 2)
                    * Math.Exp(physConstants.e * ((Iph + I0) * Rs + V) / (n * physConstants.kB * temperature));
                Func<double, double> fraction = V => V * dinputLdV(V) / (inputL(V) * (Misc.LambertW(inputL(V)) + 1));
                Func<double, double> dPdV = V => -n * physConstants.kB * temperature / (physConstants.e * Rs)
                    * Misc.LambertW(inputL(V)) * (fraction(V) + 1) + Iph + I0;

                // derviation for newton method could be determined analytically but is very messy due to second derivative of W(x)

                // return Vmpp
                return (QuickSolving.FindRootViaNewtonMethod(dPdV, 0.9 * GetVoltageOpenCircuit() / factorToVoltage, 1e-10)) * factorToVoltage;
            }

            else // Diode model with Rs and with Rp                                                               ->  I = I(Rs, Rp)
            {
                #region Plots to visualize (P needs to be maximized -> the root of dP/dV needs to be searched for)
                /*
                current over voltage
                https://www.wolframalpha.com/input/?i=plot+1%2F%288000%29*%288000*0.03*lambertW%286.87e-13*8000%2F%288000*0.03%29*exp%28%288000*0.0168-x%29%2F%288000*0.03%29%2Bx%2F0.03%29%29+%2B+x+-+8000*0.0168%29+from+x%3D0+to+0.73+and+y%3D-0.017+to+0.005
                power over voltage
                https://www.wolframalpha.com/input/?i=plot+x%2F%288000%29*%288000*0.03*lambertW%286.87e-13*8000%2F%288000*0.03%29*exp%28%288000*0.0168-x%29%2F%288000*0.03%29%2Bx%2F0.03%29%29+%2B+x+-+8000*0.0168%29+from+x%3D0+to+0.73
                derivation of power over voltage
                https://www.wolframalpha.com/input/?i=plot+d%2Fdx+%28x%2F%288000%29*%288000*0.03*lambertW%286.87e-13*8000%2F%288000*0.03%29*exp%28%288000*0.0168-x%29%2F%288000*0.03%29%2Bx%2F0.03%29%29+%2B+x+-+8000*0.0168%29%29+from+x%3D0+to+0.73
                https://www.wolframalpha.com/input/?i=plot+d%2Fdx+%28x%2F%288000%29*%288000*0.03*lambertW%286.87e-13*8000%2F%288000*0.03%29*exp%28%288000*0.0168-x%29%2F%288000*0.03%29%2Bx%2F0.03%29%29+%2B+x+-+8000*0.0168%29%29+from+x%3D0.61+to+0.6104
                */
                #endregion

                // Specify certain abbreviations (othervise lambda expression in delegate cannot access these values)
                double a = 1 / (Rs + Rp);
                double b = (Rs + Rp) * n * physConstants.kB * temperature / (physConstants.e * Rs);
                double c = Rp * (Iph + I0);
                double d = physConstants.e * I0 * Rs * Rp / ((Rs + Rp) * n * physConstants.kB * temperature);
                double g = physConstants.e * Rs / ((Rs + Rp) * n * physConstants.kB * temperature);
                double k = Rp * (Iph + I0);
                double l = physConstants.e / (n * physConstants.kB * temperature);

                // Specity certain delegate functions, where the last one will be searched for its root (maximum in power is root in derivation)
                Func<double, double> inputL = V => d * Math.Exp(g * (k - V) + l * V);
                Func<double, double> dinputLdV = V => d * (l - g) * Math.Exp(g * (k - V) + l * V);
                Func<double, double> P = V => a * (b * Misc.LambertW(inputL(V)) + V - c) * V;
                Func<double, double> fraction = V => dinputLdV(V) * Misc.LambertW(inputL(V)) / (inputL(V) * (Misc.LambertW(inputL(V)) + 1));
                Func<double, double> dPdV = V => a * (b * fraction(V) + 1) * V + a * (b * Misc.LambertW(inputL(V)) + V - c);

                // derviation for newton method could be determined analytically but is very messy due to second derivative of W(x)

                // return Vmpp
                return (QuickSolving.FindRootViaNewtonMethod(dPdV, 0.9 * GetVoltageOpenCircuit() / factorToVoltage, 1e-10)) * factorToVoltage;
            }
        }
                
        // Print parameters in console ██████████████████████████████████████████████████████████████████████████████████████████████████████████████
        /// <summary>
        /// write to console
        /// </summary>
        public void Print()
        {
            Console.WriteLine("Characeristic Curve: ");
            Console.WriteLine($"Iph = { currentPhoto * factorToCurrent }");
            Console.WriteLine($"I0  = { currentSaturation * factorToCurrent }");
            Console.WriteLine($"n   = { diode1IdealityFactor * factorToVoltage }");
            Console.WriteLine($"Rs  = { Rseries / factorToCurrent * factorToVoltage }");
            Console.WriteLine($"Rp  = { Rshunt / factorToCurrent * factorToVoltage }");
        }
    }

    public class IVcurve : NonlinearCurve
    {
        CharacteristicCurve characteristicCurve;

        double fix_Iph;
        int index_Iph = -1;

        double fix_I0;
        int index_I0 = -1;

        double fix_n;
        int index_n = -1;

        double fix_Rs;
        int index_Rs = -1;

        double fix_Rsh;
        int index_Rsh = -1;

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="temperature">temperature of this fit</param>
        /// <param name="parameterArray">initial parameters (Iph, I0, n, Rs, Rsh)</param>
        /// <param name="fitThisParameter">determines, which parameters are fitted (true) and which are not touched (false) (Iph, I0, n, Rs, Rsh)</param>
        public IVcurve(double temperature, double[] initialParams, bool[] fitThisParameter) : base(fitThisParameter.Count(e => e == true))
        {
            if (initialParams.Length != 5)
                throw new Exception("length of initialParams must be 5!");
            if (fitThisParameter.Length != 5)
                throw new Exception("length of fitThisParameter must be 5!");

            characteristicCurve = new CharacteristicCurve(temperature, initialParams[0], initialParams[1], initialParams[2], initialParams[3], initialParams[4]);

            fix_Iph = initialParams[0];
            fix_I0 = initialParams[1];
            fix_n = initialParams[2];
            fix_Rs = initialParams[3];
            fix_Rsh = initialParams[4];

            // set index of Iph
            if (fitThisParameter[0])
            {
                index_Iph = 0;
                Parameters[index_Iph] = fix_Iph;
            }

            // set index of I0
            if (fitThisParameter[1])
            {
                index_I0 = fitThisParameter.Take(1).Where(e => e).Count();
                Parameters[index_I0] = fix_I0;
            }

            // set index of n
            if (fitThisParameter[2])
            {
                index_n = fitThisParameter.Take(2).Where(e => e).Count();
                Parameters[index_n] = fix_n;
            }

            // set index of Rs
            if (fitThisParameter[3])
            {
                index_Rs = fitThisParameter.Take(3).Where(e => e).Count();
                Parameters[index_Rs] = fix_Rs;
            }

            // set index of Rsh
            if (fitThisParameter[4])
            {
                index_Rsh = fitThisParameter.Take(4).Where(e => e).Count();
                Parameters[index_Rsh] = fix_Rsh;
            }
        }

        override public double ValueAt(double voltage)
        {
            double Iph = index_Iph == -1 ? fix_Iph : Parameters[index_Iph];
            double I0 = index_I0 == -1 ? fix_I0 : Parameters[index_I0];
            double n = index_n == -1 ? fix_n : Parameters[index_n];
            double Rs = index_Rs == -1 ? fix_Rs : Parameters[index_Rs];
            double Rp = index_Rsh == -1 ? fix_Rsh : Parameters[index_Rsh];

            return characteristicCurve.GetCurrentAtVoltage(voltage, Iph, I0, n, Rs, Rp);
        }

        override public double SlopeAt(double voltage)
        {
            double Iph = index_Iph == -1 ? fix_Iph : Parameters[index_Iph];
            double I0 = index_I0 == -1 ? fix_I0 : Parameters[index_I0];
            double n = index_n == -1 ? fix_n : Parameters[index_n];
            double Rs = index_Rs == -1 ? fix_Rs : Parameters[index_Rs];
            double Rp = index_Rsh == -1 ? fix_Rsh : Parameters[index_Rsh];

            return characteristicCurve.GetCurrentAtVoltageDerivation_V(voltage, Iph, I0, n, Rs, Rp);
        }

        override public void FillPartialDerivatives(double U, DenseVector<double> grad)
        {
            double Iph = index_Iph == -1 ? fix_Iph : Parameters[index_Iph];
            double I0 = index_I0 == -1 ? fix_I0 : Parameters[index_I0];
            double n = index_n == -1 ? fix_n : Parameters[index_n];
            double Rs = index_Rs == -1 ? fix_Rs : Parameters[index_Rs];
            double Rp = index_Rsh == -1 ? fix_Rsh : Parameters[index_Rsh];
            double T = characteristicCurve.temperature;
            double e = physConstants.e;
            double kB = physConstants.kB;

            // short forms
            double exp = Math.Exp(e * Rs * (Rp * (Iph + I0) - U) / ((Rs + Rp) * n * kB * T) + e * U / (n * kB * T));
            double f = e * I0 * Rs * Rp / ((Rs + Rp) * n * kB * T) * exp;
            double W = Misc.LambertW(f);

            if (index_Iph != -1)
            {
                double dfdIph = e * Rs * Rp / ((Rs + Rp) * n * kB * T) * f;
                grad[index_Iph] = n * kB * T / (e * Rs) * dfdIph * W / (f * W + f) - Rp / (Rs + Rp);
            }

            if (index_I0 != -1)
            {
                double dfdI0 = e * Rs * Rp / ((Rs + Rp) * n * kB * T) * f + e * Rs * Rp / ((Rs + Rp) * n * kB * T) * exp;
                grad[index_I0] = n * kB * T / (e * Rs) * dfdI0 * W / (f * W + f) - Rp / (Rs + Rp);
            }

            if (index_n != -1)
            {
                double dfdn = -(e * Rs * (Rp * (Iph + I0) - U) / ((Rs + Rp) * Math.Pow(n, 2) * kB * T) + e * U / (Math.Pow(n, 2) * kB * T)) * f - e * I0 * Rs * Rp / ((Rs + Rp) * Math.Pow(n, 2) * kB * T) * exp;
                grad[index_n] = n * kB * T / (e * Rs) * dfdn * W / (f * W + f) + kB * T / (e * Rs) * W;
            }

            if (index_Rs != -1)
            {
                double dfdRs = e * Rp * (Rp * (Iph + I0) - U) / (Math.Pow(Rs + Rp, 2) * n * kB * T) * f + e * I0 * Math.Pow(Rp, 2) / (Math.Pow(Rs + Rp, 2) * n * kB * T) * exp;
                grad[index_Rs] = n * kB * T / (e * Rs) * dfdRs * W / (f * W + f) - n * kB * T / (e * Math.Pow(Rs, 2)) * W - U / Math.Pow(Rs + Rp, 2) + Rp * (Iph + I0) / Math.Pow(Rs + Rp, 2);
            }

            if (index_Rsh != -1)
            {
                double dfdRp = e * Rs * (Rs * (Iph + I0) + U) / (Math.Pow(Rs + Rp, 2) * n * kB * T) * f + e * I0 * Math.Pow(Rs, 2) / (Math.Pow(Rs + Rp, 2) * n * kB * T) * exp;
                grad[index_Rsh] = n * kB * T / (e * Rs) * dfdRp * W / (f * W + f) - U / Math.Pow(Rs + Rp, 2) - Rs * (Iph + I0) / Math.Pow(Rs + Rp, 2);
            }
        }
    }

    public class IVcurve_noRsh : NonlinearCurve
    {
        CharacteristicCurve characteristicCurve;
        public IVcurve_noRsh(double temperature, double Iph, double I0, double n, double Rs) : base(4)
        {
            Parameters[0] = Iph;
            Parameters[1] = I0;
            Parameters[2] = n;
            Parameters[3] = Rs;
            characteristicCurve = new CharacteristicCurve(temperature, Iph, I0, n, Rs, double.NaN);
        }

        override public double ValueAt(double voltage)
        {
            return characteristicCurve.GetCurrentAtVoltage(voltage, Parameters[0], Parameters[1], Parameters[2], Parameters[3], double.NaN);
        }

        override public double SlopeAt(double voltage)
        {
            return characteristicCurve.GetCurrentAtVoltageDerivation_V(voltage, Parameters[0], Parameters[1], Parameters[2], Parameters[3], double.NaN);
        }

        override public void FillPartialDerivatives(double U, DenseVector<double> grad)
        {
            double Iph = Parameters[0];
            double I0 = Parameters[1];
            double n = Parameters[2];
            double Rs = Parameters[3];
            double T = characteristicCurve.temperature;
            double e = physConstants.e;
            double kB = physConstants.kB;

            // short forms
            double exp = Math.Exp(e * ((Iph + I0) * Rs - U) / (n * kB * T));
            double f = e * I0 * Rs / (n * kB * T) * exp;
            double W = Misc.LambertW(f);

            double dfdIph = e * Rs / (n * kB * T) * f;
            grad[0] = n * kB * T / (e * Rs) * dfdIph * W / (f * W + f) - 1;

            double dfdI0 = e * Rs / (n * kB * T) * f + e * Rs / (n * kB * T) * exp;
            grad[1] = n * kB * T / (e * Rs) * dfdI0 * W / (f * W + f) - 1;

            double dfdn = -e * (Rs * (Iph + I0) + U) / (Math.Pow(n, 2) * kB * T) * f - e * I0 * Rs / (Math.Pow(n, 2) * kB * T) * exp;
            grad[2] = n * kB * T / (e * Rs) * dfdn * W / (f * W + f) + kB * T / (e * Rs) * W;

            double dfdRs = e * (Iph + I0) / (n * kB * T) * f + e * I0 / (n * kB * T) * exp;
            grad[3] = n * kB * T / (e * Rs) * dfdRs * W / (f * W + f) - n * kB * T / (e * Math.Pow(Rs, 2)) * W;
        }
    }

    public class ExpCurve : NonlinearCurve
    {
        public ExpCurve(double A, double b, double c) : base(3)
        {
            // It is convenient to set common starting values
            // for the curve parameters in the constructor:
            Parameters[0] = A;
            Parameters[1] = b;
            Parameters[2] = c;
        }

        override public double ValueAt(double x)
        {
            return Parameters[0] * Math.Exp(Parameters[1] * x) + Parameters[2];
        }

        override public double SlopeAt(double x)
        {
            return Parameters[0] * Parameters[1] * Math.Exp(Parameters[1] * x);
        }

        override public void FillPartialDerivatives(double x, DenseVector<double> f)
        {
            double exp = Math.Exp(Parameters[1] * x);
            f[0] = exp;
            f[1] = Parameters[0] * x * exp;
            f[2] = 1;
        }
    }

    public class ExpCurveFixOffset : NonlinearCurve
    {
        double offset;

        public ExpCurveFixOffset(double A, double b, double c) : base(2)
        {
            // It is convenient to set common starting values
            // for the curve parameters in the constructor:
            Parameters[0] = A;
            Parameters[1] = b;
            offset = c;
        }

        override public double ValueAt(double x)
        {
            return Parameters[0] * Math.Exp(Parameters[1] * x) + offset;
        }

        override public double SlopeAt(double x)
        {
            return Parameters[0] * Parameters[1] * Math.Exp(Parameters[1] * x);
        }

        override public void FillPartialDerivatives(double x, DenseVector<double> f)
        {
            double exp = Math.Exp(Parameters[1] * x);
            f[0] = exp;
            f[1] = Parameters[0] * x * exp;
        }
    }
}